module InductiveTypes

type three =
  | One_of_three
  | Two_of_three
  | Three_of_three

// Remember: assertions at compile-time!
let distinct = assert (One_of_three <> Two_of_three /\
                       Two_of_three <> Three_of_three /\
                       Three_of_three <> One_of_three)

let exhaustive x = assert(x = One_of_three \/
                          x = Two_of_three \/
                          x = Three_of_three)

let is_one = function
             | One_of_three -> true
             | _ -> false

let is_two (x:three) : bool = match x with
                              | Two_of_three -> true
                              | _ -> false

// Discriminators generated by F*:
let three_as_int x : int = if One_of_three? x then 1
                         else if Two_of_three? x then 2
                         else 3

// Exhaustiveness checking is a semantic check:
let only_two_as_int (x:three {not (Three_of_three? x)}) : int
  = match x with
    | One_of_three -> 1
    | Two_of_three -> 2

// Tuples
type tup2 (a:Type) (b:Type) =
  | Tup2 : fst:a -> snd:b -> tup2 a b

// Project a component from tuple:
let tup2_fst #a #b (x:tup2 a b) : a
  = match x with
    | Tup2 fst _ -> fst

// Projectors are auto-generated:
// Tup2?.fst

// Records:
open FStar.Mul
type point3D = {x:int; y:int; z:int}
let origin = {x=0; y=0; z=0}
let dot (p0 p1:point3D) = p0.x * p1.x + p0.y * p1.y + p0.z * p1.z
let translate_X (p:point3D) (shift:int) = {p with x = p.x + shift}
let is_origin = function
  | {z=0; y=0; x=0} -> true
  | _ -> false

// Mutual recursion
type tree =
  | Terminal : tree
  | Internal : node -> tree
and node = {
  left: tree;
  data: int;
  right: tree
}

let rec incr_tree = function
  | Terminal -> Terminal
  | Internal n -> Internal (incr_node n)
and incr_node n = {
  left = incr_tree n.left;
  data = n.data + 1;
  right = incr_tree n.right
}
